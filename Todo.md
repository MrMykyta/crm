# TODO — CRM Platform (for Codex)
Дата: 14.01.2026  
Цель: получить **SaaS-ready** платформу CRM с multi-tenant, RBAC и подписками (plans).
Правило: Codex выполняет задачи **строго по приоритетам** и **строго в стиле проекта**, описанном в `Readme.md`.

Текущее состояние (важно для приоритизации):
- Backend: базово подготовлен (архитектура и сущности в целом понятны), но требует доводки по P0–P3
- Frontend: существенно сырой по многим пунктам — приоритет на стандартизацию store, вынос shared UI и выравнивание Front ↔ Back

---

## 0) Глобальные правила Codex (обязательные)

### 0.1 Запрещено
- Писать код без разрешения в рамках конкретного пункта TODO
- Делать “рефактор ради рефактора”
- Менять архитектуру (store, multi-tenant, RBAC) без явной задачи
- Добавлять `client/api` слой (на фронте **только store**)
- Переписывать “базовые сущности”, которые уже написаны в проекте (минимальные правки только по делу)
- Ломать API контракты, которые уже использует фронт (если надо — делать совместимый слой)

### 0.2 Обязательно
- Backend: `module.exports` + `try/catch` + `next(error)` в каждом методе контроллера
- Любые изменения — **точечные**, с обоснованием “почему” и “что это исправляет”
- Любая логика доступа: **role/permission + plan** (две проверки)
- Multi-tenant scope (companyId) обязателен во всех запросах к данным компании
- Все критичные изменения сопровождаются “как проверить” (минимальный smoke checklist)
- Frontend: новые экраны собираются из переиспользуемых компонентов (сначала ищем повтор, потом вынос в components/shared)
- Перед созданием нового UI-компонента Codex обязан проверить существующие shared/components и переиспользовать их

### 0.3 Формат работы по каждому пункту TODO
Для каждого пункта:
1) Кратко: что не так сейчас
2) Конкретно: какие файлы затронуть
3) Патч: изменения по файлам (дифф или полный файл)
4) Проверка: как руками проверить (1–5 шагов)

---

## 1) P0 — Security & SaaS-core (БЛОКЕРЫ)
Критерий: пока P0 не закрыт — SaaS продавать нельзя.

### 1.1 Multi-tenant enforcement (company scope) — ВЕЗДЕ
**Задача:** устранить риск утечки данных между компаниями.

#### Требования
- `companyId` всегда берётся из `req.user.companyId`
- Запрещено принимать `companyId` из body/query/params для бизнес-сущностей
- Любой `find*/update/destroy` по бизнес-сущности обязан включать `companyId` в where
- Для update/delete обязателен “ownership check”

#### Реализация (шаблон)
- Ввести единый helper/policy (не ломая стиль):
  - `scopeByCompany(where, req.user.companyId)` или аналог
- В сервисах заменить:
  - `Model.findByPk(id)` → `Model.findOne({ where: { id, companyId } })`
- Для include связей: не допускать подмешивания чужих entity

#### DoD (Definition of Done)
- Нет ни одного сервиса/контроллера, который отдаёт бизнес-данные без `companyId` scope
- Нет чтения `companyId` из body/query/params для бизнес-операций
- Добавлен минимальный автотест или хотя бы manual test кейс: userA не видит data userB

---

### 1.2 RBAC (roles + permissions) — привести в рабочее состояние
**Задача:** permissions должны реально контролировать доступ на backend.

#### Требования
- CRUD permissions минимум для ключевых доменов: companies, users, roles, counterparties, contacts, deals, tasks, products, orders, warehouse
- Проверки выполняются:
  - middleware (если общие)
  - service-level (если контекстные)
- Исправить опечатки/несоответствия в permission keys (пример: `compamy:*`)

#### DoD
- Для ключевых эндпоинтов есть фактическая проверка permissions
- При отсутствии permission возвращается 403 (или согласованный код)
- Frontend не является источником истины по доступу

---

### 1.3 Подписки (Plans) + Feature gating (backend) — базовый каркас
**Задача:** планы ограничивают функциональность и лимиты.

#### Требования
- План привязан к company
- Feature map хранится в БД или конфиге (в рамках текущей архитектуры)
- На backend есть механизм проверки:
  - `requireFeature('module.x')`
  - `checkLimit('users')`
- Ошибки:
  - 402/403 (как согласуете) с `code=PLAN_RESTRICTED` или аналог

#### Минимальный MVP
- 2–3 фичи для проверки (например: AI Assistant, Automations, Advanced Reports)
- 1–2 лимита (например: usersCount, storage)

#### DoD
- Есть сущности/поля, позволяющие хранить plan/features/limits
- Есть middleware/service helper для проверки feature/limit
- 2–3 эндпоинта реально защищены планом

---

### 1.4 Единый error handler и requestId
**Задача:** наблюдаемость, трассировка и стабильность ответа.

#### Требования
- В каждом запросе генерировать `requestId`
- Возвращать `meta.requestId` в ответах
- Ошибки всегда идут через `next(error)`
- Ошибки имеют `code` (минимум: AUTH, PERMISSION, PLAN, VALIDATION, NOT_FOUND, INTERNAL)

#### DoD
- requestId присутствует в логах и в meta ответа
- Ошибки возвращаются в едином формате

---

## 2) P1 — API Contract & Integration (Front ↔ Back)

### 2.1 Нормализовать ответы API (постепенно, модуль за модулем)
**Задача:** привести ответы к `{ data, meta }`, не ломая фронт.

#### Подход
- Сначала системные и CRM эндпоинты
- Если фронт ждёт другой формат — добавить совместимость:
  - временно поддерживать оба, или
  - адаптер на фронте в store (предпочтительно)

#### DoD
- Для выбранного набора эндпоинтов формат стабилен
- List endpoints возвращают `meta.pagination`

---

### 2.2 Pagination / sorting / filtering (list endpoints)
**Задача:** все списки единообразны.

#### Требования
- `page`, `pageSize`, `sortBy`, `sortDir`, `q`
- `meta.pagination.total` обязателен
- Ограничить максимально допустимый pageSize (защита)

#### DoD
- 3–5 ключевых list endpoints переведены на стандарт
- Store на фронте умеет хранить filters/pagination и менять запросы

---

### 2.3 Валидация входных данных (backend)
**Задача:** убрать “undefined crashes” и сделать предсказуемые 400.

#### Требования
- Валидация до service
- Ошибка 400 с `code=VALIDATION_ERROR` + details
- Не плодить разные форматы ошибок

#### DoD
- 5–10 ключевых эндпоинтов валидируются
- Нет падений из-за отсутствующих полей

---

### 2.4 Front ↔ Back route alignment (интеграционный долг)
**Задача:** устранить рассинхрон путей, параметров и полей.

#### Требования
- Сверить фактические эндпоинты с тем, что вызывает store/pages
- Исправить:
  - неверные path params
  - неверные query params
  - mismatch в названиях полей
- Никаких “магических” преобразований в UI

#### DoD
- Ключевые разделы UI работают без 404/500
- Store не вызывает несуществующие endpoints

---

## 3) P2 — Frontend Store quality & UI reuse

### 3.1 Store стандарты (структура, async, кеш, invalidation)
**Задача:** предсказуемый data-flow.

#### Требования
- Описать и привести к единому стилю:
  - slices/modules naming
  - async actions / thunks
  - selectors
  - error handling
  - loading states
  - caching + invalidation strategy
- Запретить запросы из UI (проверить)

#### DoD
- Store имеет единые паттерны по 2–3 модулям
- Нет HTTP запросов в pages/components

---

### 3.2 UI reuse: вынести повторяющиеся блоки в компоненты
**Задача:** убрать дублирование и ускорить разработку.

#### Требования
- Если разметка/логика повторяется ≥2 раз — вынести в `client/components` или принятую shared-папку
- Компоненты UI без бизнес-логики
- Props минимальные и понятные
- CSS Modules, стиль проекта

#### Типовые кандидаты
- Table wrapper + pagination bar
- EmptyState / ErrorState / Loader
- PageHeader (title + actions)
- ConfirmModal
- FormRow / InputGroup

#### DoD
- 3–5 реально повторяющихся блоков вынесены
- Страницы упростились, UI не изменился визуально без причины

---

## 4) P3 — Audit / Logs, Files, Realtime

### 4.1 Audit logs (важные действия)
**Задача:** фундамент для безопасности и AI.

#### Требования
- Логировать:
  - actor userId
  - companyId
  - entity + entityId
  - action
  - timestamp
  - before/after (где разумно)

#### DoD
- 5–10 критичных действий логируются (создание/обновление ключевых сущностей)
- Есть способ просмотра/экспорта (минимум API)

---

### 4.2 Attachments / Files (если уже есть — привести к стандарту; если нет — каркас)
**Задача:** изоляция файлов по company + контроль доступа.

#### Требования
- Метаданные файлов в БД: `companyId`, `entity`, `entityId`, `path/url`, `mime`, `size`, `createdBy`
- Backend проверяет права на скачивание
- Запрещено отдавать файлы другой компании

#### DoD
- Upload + download работают с company scope
- Минимальный UI (или endpoints) для привязки к сущности

---

### 4.3 Realtime (SSE/WebSocket) — company-safe events
**Задача:** realtime не должен утекать между tenants.

#### Требования
- Каналы/события привязаны к company
- Формат события: `{ type, payload, timestamp }`
- Client подписывается только на свою company

#### DoD
- 1–2 события работают и не видны другим компаниям
- Документация в README обновлена (если нужно)

---

## 5) P4 — Модули и UI (по макетам/скринам)

Цель: по очереди реализовывать/допиливать модули **строго по макетам/скриншотам** (в т.ч. по скринам Санька), чтобы Codex всегда понимал “как должно выглядеть и работать”.

### 5.1 Процесс работы по модулю (обязательный)
На каждый модуль/экран:
1) Мы добавляем в репозиторий скрины/описание (или даём в чат), фиксируем требования
2) Codex делает **только отчёт**: что уже есть, чего нет, какие файлы затрагиваются
3) После разрешения — Codex делает патч и описывает проверки

### 5.2 Module Spec (шаблон, который Codex обязан соблюдать)
Для каждого модуля/экрана создаём описание (можно отдельным файлом в `docs/specs/` или в TODO по ссылке), минимум:

- Название модуля/экрана
- Цель и пользовательские сценарии (use-cases)
- Роли/permissions и ограничения по plan
- API/Store: какие данные нужны, какие actions вызываются, формат данных
- UI: структура страницы (layout), блоки, таблицы, фильтры, формы, модалки
- Empty/Error/Loading states
- Edge cases (пустые данные, нет прав, лимит плана, ошибки сети)
- Realtime (если нужно): какие события слушаем и как обновляем store
- Acceptance Criteria (что значит “готово”)

### 5.3 UI Reuse — обязательное правило
- Любой новый экран строится из **переиспользуемых компонентов**
- Если повторяется ≥2 раз — вынос в shared/components
- Компоненты:
  - без бизнес-логики
  - props минимальные
  - CSS Modules
- Страницы должны содержать только композицию и логику связки со store

DoD:
- По каждому сделанному модулю есть Module Spec
- Нет дублирующихся одинаковых UI-блоков по проекту без причины

---

## 6) Deliverables (артефакты проекта)

### 7.1 Domain Map (docs/domain-map.md или в README)
**Задача:** карта сущностей и ответственности.

Для каждой сущности:
- назначение
- ключевые поля
- связи
- permissions
- plan restrictions
- основные UI-флоу

### 7.2 Postman/Insomnia коллекция (если используется)
- экспорт коллекции для ключевых эндпоинтов
- примеры запросов

### 7.3 Smoke checklist
- минимальные шаги проверки после деплоя

---

## 7) План исполнения (рекомендуемая последовательность)
1) P0: Multi-tenant scope → RBAC → Plans → Error/requestId
2) P1: API contract → pagination/validation → route alignment
3) P2: Store стандарты → UI reuse
4) P3: Audit/Files/Realtime
5) P4: Модули и UI (по макетам/скринам)
6) Deliverables: Domain Map, коллекции, smoke checklist

---

## 8) Формат результата от Codex
После выполнения каждого пункта:
- список изменённых файлов
- краткое описание изменений
- инструкции проверки
- если есть риск регрессии — указать где и почему

---

## 9) Запуск следующего этапа
После закрытия P0 и P1:
- сформировать `Roadmap.md` (по неделям)
- сформировать `Backlog.md` (feature идеи)
